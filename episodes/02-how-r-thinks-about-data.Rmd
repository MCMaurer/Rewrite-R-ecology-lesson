---
title: "Exploring and understanding data"
teaching: 45
exercises: 4
---

:::::::::::::::::::::::::::::::::::::: questions 

- How does R store and represent data?

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- Explore the structure and content of dataframes
- Understand vector types and missing data
- Use vectors as function arguments
- Create and convert factors
- Understand how R assigns values to objects

::::::::::::::::::::::::::::::::::::::::::::::::


## Setup

```{r, include=F}
knitr::opts_chunk$set(dpi = 200, out.height = 600, out.width = 600, R.options = list(max.print = 100))
```

```{r load-tidyverse-package, message=FALSE}
library(tidyverse)
```

```{r load-ratdat-package,message=FALSE}
library(ratdat)
surveys <- left_join(left_join(surveys, species), plots) %>% 
  mutate(across(where(is.factor), as.character))
```   

## The data.frame

We just spent quite a bit of time learning how to create visualizations from the `surveys` data, but we did not talk much about **what** this `surveys` thing is. It's important to understand how R thinks about, represents, and stores data in order for us to have a productive working relationship with R.

The `surveys` data is stored in R as a `data.frame`, which is the most common way that R represents tabular data (data that can be stored in a table format). We can check what `surveys` is by using the `class()` function:

```{r class}
class(surveys)
```

We can view the first few rows with the `head()` functions:

```{r head}
head(surveys)
```

We used these functions with just one argument, the object `surveys`, and we didn't give the argument a name, like we did with `ggplot2`. In R, a function's arguments come in a particular order, and if you put them in the correct order, you don't need to name them. In this case, the name of the argument is `x`, so we can name it if we want, but since we know it's the first argument, we don't need to.

To learn more about a function, you can type a `?` in front of the name of the function, which will bring up the official documentation for that function:

```{r, head-help}
?head
```

Some arguments are optional. For example, the `n` argument in `head()` specifies the number of rows to print. It defaults to 6, but we can override that by specifying a different number:

```{r head-n}
head(surveys, n = 10)
```

If we order them correctly, we don't have to name either:

```{r head-n-noname}
head(surveys, 10)
```

Additionally, if we name them, we can put them in any order we want:

```{r head-reverse}
head(n = 10, x = surveys)
```

Generally, it's good practice to start with the required arguments, like the dataframe whose rows you want to see, and then to name the optional arguments. If you are ever unsure, it never hurts to explicitly name an argument.

Let's get back to investigating our `surveys` dataframe. We can get some useful summaries of each variable using the `summary()` function:

```{r}
summary(surveys)
```

And, as we have already done, we can use `str()` to look at the structure of an object:

```{r}
str(surveys)
```

We get quite a bit of useful information here. First, we are told that we have a `data.frame` of `r nrow(surveys)` observations, or rows, and `r ncol(surveys)` variables, or columns.

Next, we get a bit of information on each variable, including its type (`int` or `chr`) and a quick peek at the first 10 values. You might ask why there is a `$` in front of each variable. This is because the `$` is an operator that allows us to select individual columns from a dataframe.

The `$` operator also allows you to use tab-completion to quickly select which variable you want from a given dataframe. For example, to get the `year` variable, we can type `surveys$` and then hit <kbd>Tab</kbd>. We get a list of the variables that we can move through with up and down arrows. Hit <kbd>Enter</kbd> when you reach `year`, which should finish this code:

```{r dollar-subsetting}
surveys$year
```

What we get back is a whole bunch of numbers, the entries in the `year` column printed out in order.

## Vectors: the building block of data

You might have noticed that our last result looked different from when we printed out the `surveys` dataframe itself. That's because it is not a dataframe, it is a **vector**. A vector is a 1-dimensional series of values, in this case a vector of numbers representing years.

Dataframes are made up of vectors; each column in a dataframe is a vector. Vectors are the basic building blocks of all data in R. Basically, everything in R is a vector, a bunch of vectors stitched together in some way, or a function. Understanding how vectors work is crucial to understanding how R treats data, so we will spend some time learning about them.

There are 4 main types of vectors (also known as *atomic vectors*):

1. `"character"` for strings of characters, like our `genus` or `sex` columns. Each entry in a character vector is wrapped in quotes.

2. `"integer"` for integers. All the numeric values in `surveys` are integers. You may sometimes see integers represented like `2L` or `20L`. The `L` indicates to R that it is an integer, instead of the next data type, `"numeric"`.

3. `"numeric"`, aka `"double"`, vectors can contain numbers including decimals.

4. `"logical"` for `TRUE` and `FALSE`, which can also be represented as `T` and `F`.

Vectors can only be of a **single type**. Since each column in a dataframe is a vector, this means an accidental character following a number, like `29,` can change the type of the whole vector. Mixing up vector types is one of the most common mistakes in R, and it can be tricky to figure out. It's often very useful to check the types of vectors.

To create a vector from scratch, we can use the `c()` function, putting values inside, separated by commas.

```{r c-vector}
c(1, 2, 5, 12, 4)
```

As you can see, those values get printed out in the console, just like with `surveys$year`. To store this vector so we can continue to work with it, we need to assign it to an object.

```{r assign-vector}
num <- c(1, 2, 5, 12, 4)
```

```{r}
class(num)
typeof(num)
```

```{r}
char <- c("apple", "pear", "grape")
```

```{r}
typeof(char)
```

```{r}
logi <- c(TRUE, FALSE, TRUE, TRUE)
```

```{r}
typeof(logi)
```

::::::::::::::::::::::::::::::::::::: challenge 

## Challenge 1: Coercion

1. What type will each of these vectors be? Try to guess without running any code, but you can use `class()` to verify your answers.

```{r coercion-challenge}
num_logi <- c(1, 4, 6, TRUE)
num_char <- c(1, 3, "10", 6)
char_logi <- c("a", "b", TRUE)


tricky <- c("a", "b", "1", FALSE)
```


:::::::::::::::::::::::: solution 

```{r coercion-challenge-answer}
class(num_logi)
class(num_char)
class(char_logi)
class(tricky)
```

R will automatically convert values in a vector so that they are all the same type, a process called **coercion**.

::::::::::::::::::::::::

2. How many values in `combined_logical` are `"TRUE"` (as a character)? 

```{r combined-logical-challenge}
combined_logical <- c(num_logi, char_logi)
```

:::::::::::::::::::::::: solution 

```{r combined-logical-challenge-answer}
class(combined_logical)
```
 
Only one value is `"TRUE"`. Coercion happens when each vector is created, so the `TRUE` in `num_logi` becomes a `1`, while the `TRUE` in `char_logi` becomes `"TRUE"`. When these two vectors are combined, R doesn't remember that the `1` in `num_logi` used to be a `TRUE`, it will just coerce the `1` to `"1"`.

::::::::::::::::::::::::

3. Now that you've seen a few examples of coercion, you might have started to see that there are some rules about what types get converted. There is a hierarchy to coercion. Can you draw a diagram that represents the hierarchy of what types get converted to other types?

:::::::::::::::::::::::: solution 

logical → integer → numeric → character

Logical vectors can only take on two values: `TRUE` or `FALSE`. Integer vectors can only contain integers, so `TRUE` and `FALSE` can be coerced to `1` and `0`. Numeric vectors can contain numbers with decimals, so integers can be coerced from, say, `6` to `6.0` (though R will still display a numeric `6` as `6`.). Finally, any string of characters can be represented as a character vector, so any of the other types can be coerced to a character vector.
::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::


Coercion is not something you will often do intentionally; rather, when combining vectors or reading data into R, a stray character that you missed may change an entire numeric vector into a character vector. It is a good idea to check the `class()` of your results frequently, particularly if you are running into confusing error messages.

## Missing data

One of the great things about R is how it handles missing data, which can be tricky in other programming languages. R represents missing data as `NA`, without quotes. Let's make a numeric vector with an `NA` value:

```{r na-vec}
weights <- c(25, 34, 12, NA, 42)
```

R doesn't make assumptions about how you want to handle missing data, so if we pass this vector to a numeric function like `min()`, it won't know what to do, so it returns `NA`:

```{r func-na}
min(weights)
```

This is a very good thing, since we won't accidentally forget to consider our missing data. If we decide to exclude our missing values, many functions have an argument to **r**e**m**ove them:

```{r func-na-rm}
min(weights, na.rm = TRUE)
```

## Vectors as arguments

A common use for creating vectors from scratch is in function arguments. The `quantile()` function will calculate a quantile for a given vector of numeric values. We set the quantile using the `probs` argument. We also need to set `na.rm = TRUE`, since there are `NA` values in the `weight` column, and R doesn't know how to calculate a quantile if there are `NA`s. This is a common argument for lots of numeric functions.

```{r single-quantile}
quantile(surveys$weight, probs = 0.25, na.rm = TRUE)
```

Now we get back the 25% quantile value for weights. However, we often want to know more than one quantile. Luckily, the `probs` argument is **vectorized**, meaning it can take a whole vector of values. Let's try getting the 25%, 50% (median), and 75% quantiles all at once.

```{r multi-quantile}
quantile(surveys$weight, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)
```

While the `c()` function is very flexible, it doesn't necessarily scale well. If you want to generate a long vector from scratch, you probably don't want to type everything out manually. There are a few functions that can help generate vectors.

First, putting `:` between two numbers will generate a vector of integers starting with the first number and ending with the last. The `seq()` function allows you to generate similar sequences, but changing by any amount. Finally, the `rep()` function allows you to repeat a value, or even a whole vector, as many times as you want, and works with any type of vector.

```{r seq-rep}
1:10

seq(from = 0, to = 1, by = 0.1)


rep("a", 12)

rep(c("a", "b", "c"), 4)
```

## Building with vectors

We have now seen vectors in a few different forms: as columns in a dataframe and as single vectors. However, they can be manipulated into lots of other shapes and forms. Some other common forms are:

- matrices
  - 2-dimensional numeric representations
- arrays
  - many-dimensional numeric
- lists
  - lists are very flexible ways to store vectors
  - a list can contain vectors of many different types and lengths
  - an entry in a list can be another list, so lists can get deeply nested
  - a dataframe is just a list where each vector has to be the same length (dataframes are rectangular)
- factors
  - a way to represent categorical data
  - factors can be ordered or unordered
  - they often *look* like character vectors, but behave differently
  - under the hood, they are integers with character labels, called **levels**, for each integer

### Factors

We will spend a bit more time talking about factors, since they are often a challenging type of data to work with. We can create a factor from scratch by putting a character vector made using `c()` into the `factor()` function:

```{r factors}
sex <- factor(c("male", "female", "female", "male", "female", NA))

sex
```

We can inspect the levels of the factor using the `levels()` function:

```{r levels}
levels(sex)
```

The **`forcats`** package from the `tidyverse` has a lot of convenient functions for working with factors. We will show you a few common operations, but the `forcats` package has many more useful functions.

```{r forcats}
library(forcats)

# change the order of the levels
fct_relevel(sex, c("male", "female"))

# change the names of the levels
fct_recode(sex, "M" = "male", "F" = "female")

# turn NAs into explicit missing values (useful for including NAs in plots)
fct_explicit_na(sex)

```

In general, it is a good practice to leave your categorical data as a **character** vector until you need to use a factor. Here are some reasons you might need a factor:

1. Another function requires you to use a factor
2. You are plotting categorical data and want to control the ordering of categories in the plot

Since factors can behave differently from character vectors, it is always a good idea to check what type of data you're working with. You might use a new function for the first time and be confused by the results, only to realize later that it produced a factor as an output, when you thought it was a character vector.

It is fairly straightforward to convert a factor to a character vector:

```{r factor-character}
as.character(sex)
```

However, you need to be careful if you're somehow working with a factor that has numbers as its levels:

```{r factor-numeric}
f_num <- factor(c(1990, 1983, 1977, 1998, 1990))

# this will pull out the underlying integers, not the levels
as.numeric(f_num)

# if we first convert to characters, we can then convert to numbers
as.numeric(as.character(f_num))
```

## Assignment, objects, and values

We've already created quite a few objects in R using the `<-` assignment arrow, but there are a few finer details worth talking about. First, let's start with a quick challenge.

::::::::::::::::::::::::::::::::::::: challenge

## Challenge X:

What is the value of `y` after running the following code?

```{r assignment-challenge, eval=F}
x <- 5
y <- x
x <- 10
```


:::::::::::::::::::::::: solution

```{r assignment-challenge-answer}
x <- 5
y <- x
x <- 10
y
```

::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::

Understanding what's going on here will help you avoid a lot of confusion when working in R. When we assign something to an object, the first thing that happens is the righthand side gets *evaluated*. The same thing happens when you run something in the console: if you type `x` into the console and hit <kbd>Enter</kbd>, R returns the value of `x`. So when we first ran the line `y <- x`, `x` first gets evaluated to the value of `5`, and this gets assigned to `y`. The objects `x` and `y` are not actually linked to each other in any way, so when we change the value of `x` to `10`, `y` is unaffected.

This also means you can run multiple nested operations, store intermediate values as separate objects, or overwrite values:

```{r assignments}
x <- 5

# first, x gets evaluated to 5
# then 5/2 gets evaluated to 2.5
# then sqrt(2.5) is evaluated
sqrt(x/2)

# we can also store the evaluated value of x/2 
# in an object y before passing it to sqrt()
y <- x/2

sqrt(y)

# first, the x on the righthand side gets evaluated to 5
# then 5 gets squared
# then the resulting value is assigned to the object x

x <- x^2

x
```

You will be naming a of objects in R, and there are a few common naming rules and conventions:

- make names clear without being too long
  - `wkg` is probably too short
  - `weight_in_kilograms` is probably too long
  - `weight_kg` is great
- names cannot start with a number
- names are case sensitive
- you cannot use the names of fundamental functions in R, like `if`, `else`, or `for`
  - in general, avoid using names of common functions like `c`, `mean`, etc.
- avoid dots `.` in names, as they have a special meaning in R, and may be confusing to others
- be consistent
- you can use a style guide like [Google's](https://google.github.io/styleguide/Rguide.xml) or
[tidyverse's](http://style.tidyverse.org/)
